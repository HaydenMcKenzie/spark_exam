Setup
    SET logger error
    CREATE SparkSession

    READ in files
        CREATE customerData
            from customer_data.csv
        CREATE accountData
            from account_data.csv
        READ addressData
            from address_data.csv


Transform Data - Question 1
    JOIN accountData to customerData by "customerId"

    GROUPBY "customerId", "forename", "surname"
        CREATE Seq of all accountsId with the same "customerId", "forename", "surname".
            ALIAS column "accounts"
        COUNT elements in Seq of "accountId".
            ALIAS column "numberAccounts"
        ADD all numbers from "balance" and round to 2 decimal places.
            ALIAS column "totalBalance"
        AVERAGE all numbers from "balance" and round to 2 decimal places.
            ALIAS column "averageBalance"

    WRITE TO FILE
        Save as a Parquet file
        SHOW new Dataset



Transform Data - Question 2
    READ Parguet file
        from Question 1
    PARSE "address" column in addressData
        from SetUp.scala

    JOIN addressData to Parguet file via "customerId" column
    CREATE customer document
        SELECT addressId, customerId, address, number, road, city, country. Make them a struct
        GROUPBY customerId, forename, surname, accounts
        CREATE new column called "address"
        SELECT customerId, forename, surname, accounts, address.
            Put it in the AddressData schema

    SHOW new Dataset


"""
  test("Test RawAccountSchema") {
    val account = RawAccountData("1", "ACC001", 100.0)
    assert(account.customerId == "1")
    assert(account.accountId == "ACC001")
    assert(account.balance == 100.0)
  }

  test("Test RawAddressSchema") {
    val address = RawAddressData("1", "1", "123 Main St")
    assert(address.addressId == "1")
    assert(address.customerId == "1")
    assert(address.address == "123 Main St")
  }

  test("Test AddressSchema") {
    val address = AddressData("1", "1", "123 Main St", Some(10), Some("Main St"), Some("City"), Some("Country"))
    assert(address.addressId == "1")
    assert(address.customerId == "1")
    assert(address.address == "123 Main St")
    assert(address.number.contains(10))
    assert(address.road.contains("Main St"))
    assert(address.city.contains("City"))
    assert(address.country.contains("Country"))
  }

  test("Test CustomerDocument") {
    import com.nuvento.sparkexam.utils.SparkSetup.spark.implicits._

    val data1: Dataset[AddressData] = Seq(AddressData("1", "1", "123 Main St", Some(10), Some("Main St"), Some("City"), Some("Country"))).toDS()
    val addressDataSeq: Dataset[AddressData] = parseAddress(data1, "address")

    val accountIds: Seq[AccountData] = Seq(
      AccountData("1", "ACC001", 0.0),
      AccountData("1", "ACC002", 0.0)
    )

    val document = Schemas.CustomerDocument("1", "Alice", "Smith", accountIds, addressDataSeq.collect())

    // Extract address strings from AddressSchema objects
    val expectedAddresses = addressDataSeq.collect().map(_.address).toSeq
    assert(document.address.map(_.address) == expectedAddresses) // Compare only the address field
  }

  test("Test CustomerAccountOutput") {
    // Define sample data
    val customerId = "IND0113"
    val forename = "Leonard"
    val surname = "Ball"
    val accounts = Seq(RawAccountData("IND0113", "ACC0577", 531))
    val numberAccounts = 1
    val totalBalance = 531L
    val averageBalance = 531.0

    val customerAccountOutput = CustomerAccountOutput(customerId, forename, surname, accounts, numberAccounts, totalBalance, averageBalance)

    // Assert fields of CustomerAccountOutput
    assert(customerAccountOutput.customerId === customerId)
    assert(customerAccountOutput.forename === forename)
    assert(customerAccountOutput.surname === surname)
    assert(customerAccountOutput.accounts === accounts)
    assert(customerAccountOutput.numberAccounts === numberAccounts)
    assert(customerAccountOutput.totalBalance === totalBalance)
    assert(customerAccountOutput.averageBalance === averageBalance)
  }

  test("Test customerSchemaEncoder") {
    val test = Encoders.product[RawCustomerData]
    assert(rawCustomerDataEncoder.equals(test))
  }

  test("Test rawAccountDataEncoder") {
    val test = Encoders.product[RawAccountData]
    assert(rawAccountDataEncoder.equals(test))
  }

  test("Test accountDataEncoder") {
    val test = Encoders.product[AccountData]
    assert(accountDataEncoder.equals(test))
  }

  test("Test addressDataEncoder") {
    val test = Encoders.product[AddressData]
    assert(addressDataEncoder.equals(test))
  }

  test("Test customerDocumentEncoder") {
    val test = Encoders.product[CustomerDocument]
    assert(customerDocumentEncoder.schema == test.schema)
  }

  test("Test customerAccountOutputEncoder") {
    val test = Encoders.product[CustomerAccountOutput]
    assert(customerAccountOutputEncoder.schema == test.schema)
  }
  """




  ////

    case class RawAccountData(customerId: String,
                              accountId: String,
                              balance: Double)

    // Question One Final Schema
    case class CustomerAccountOutput(customerId: String,
                                     forename: String,
                                     surname: String,
                                     accounts: Seq[RawAccountData],
                                     numberAccounts: Integer,
                                     totalBalance: Long,
                                     averageBalance: Double)

    implicit val rawAccountDataEncoder: Encoder[RawAccountData] = Encoders.product[RawAccountData]
    implicit val customerAccountOutputEncoder: Encoder[CustomerAccountOutput] = Encoders.product[CustomerAccountOutput]


    // Question Two File Schemas
    case class RawAddressData(addressId: String,
                              customerId: String,
                              address: String)

    // Extra
    case class AccountData(customerId: String,
                           accountId: String,
                           balance: Double)

    case class AddressData(addressId: String,
                           customerId: String,
                           address: String,
                           number: Option[Int],
                           road: Option[String],
                           city: Option[String],
                           country: Option[String])

    // Question Two Final Schema
    case class CustomerDocument(customerId: String,
                                forename: String,
                                surname: String,
                                accounts: Seq[AccountData],
                                address: Seq[AddressData])

    // Question Two Encoders
    implicit val rawAddressDataEncoder: Encoder[RawAddressData] = Encoders.product[RawAddressData]
    implicit val accountDataEncoder: Encoder[AccountData] = Encoders.product[AccountData]
    implicit val addressDataEncoder: Encoder[AddressData] = Encoders.product[AddressData]
    implicit val customerDocumentEncoder: Encoder[CustomerDocument] = Encoders.product[CustomerDocument]